// 1. Contains Duplicate:

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

bool containsDuplicate(int* nums, int numsSize) {
    qsort(nums, numsSize, sizeof(int), compare);
    for (int i = 0; i < numsSize - 1; i++) {
        if (nums[i] == nums[i + 1]) {
            return true;
        }
    }
    return false;
}



// 2. Missing Number:

#include <stdio.h>

int missingNumber(int* nums, int numsSize) {
    int expectedSum = (numsSize * (numsSize + 1)) / 2; 
    int actualSum = 0;  

    for (int i = 0; i < numsSize; i++) { 
        actualSum += nums[i];
    }

    return expectedSum - actualSum;  
}



// 3. Two Sum:

#include <stdio.h>
#include <stdlib.h>

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    *returnSize = 2;
    int* result = (int*)malloc(2 * sizeof(int));  

    for (int i = 0; i < numsSize - 1; i++) {
        for (int j = i + 1; j < numsSize; j++) {
            if (nums[i] + nums[j] == target) {  
                result[0] = i;
                result[1] = j;
                return result; 
            }
        }
    }
    return NULL; 
}



// 4. How Many Numbers Are Smaller Than the Current Number:

#include <stdio.h>
#include <stdlib.h>

int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize) {
    *returnSize = numsSize;
    int* result = (int*)malloc(numsSize * sizeof(int));

    for (int i = 0; i < numsSize; i++) {
        int count = 0;
        for (int j = 0; j < numsSize; j++) {
            if (nums[j] < nums[i]) {
                count++;
            }
        }
        result[i] = count;
    }
    return result;
}



// 5. Minimum Time Visiting All Points:

#include <stdio.h>
#include <stdlib.h>

int minTimeToVisitAllPoints(int** points, int pointsSize, int* pointsColSize) {
    int totalTime = 0;

    for (int i = 0; i < pointsSize - 1; i++) {
        int dx = abs(points[i + 1][0] - points[i][0]); 
        int dy = abs(points[i + 1][1] - points[i][1]); 
        totalTime += (dx > dy) ? dx : dy;
    }

    return totalTime;
}



// 6. Spiral Matrix:

#include <stdio.h>
#include <stdlib.h>

int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {
    if (matrixSize == 0 || matrixColSize[0] == 0) {
        *returnSize = 0;
        return NULL;
    }

    int m = matrixSize, n = matrixColSize[0]; 
    *returnSize = m * n; 

    int* result = (int*)malloc((*returnSize) * sizeof(int));
    if (!result) return NULL; 

    int top = 0, bottom = m - 1;
    int left = 0, right = n - 1;
    int index = 0;

    while (top <= bottom && left <= right) {
         for (int i = left; i <= right; i++) {
            result[index++] = matrix[top][i];
        }
        top++;

        for (int i = top; i <= bottom; i++) {
            result[index++] = matrix[i][right];
        }
        right--;

        if (top <= bottom) {
            for (int i = right; i >= left; i--) {
                result[index++] = matrix[bottom][i];
            }
            bottom--;
        }
        
        if (left <= right) {
            for (int i = bottom; i >= top; i--) {
                result[index++] = matrix[i][left];
            }
            left++;
        }
    }

    return result;
}


// 7. Best Time to Buy and Sell Stock:

#include <stdio.h>
#include <limits.h> 

int maxProfit(int* prices, int pricesSize) {
    if (pricesSize < 2) return 0; 

    int minPrice = INT_MAX; 
    int maxProfit = 0;      

    for (int i = 0; i < pricesSize; i++) {
        if (prices[i] < minPrice) {
            minPrice = prices[i]; 
        } else {
            int profit = prices[i] - minPrice; 
            if (profit > maxProfit) {
                maxProfit = profit; 
            }
        }
    }

    return maxProfit;
}


// 8. Squares of a Sorted Array:


#include <stdio.h>
#include <stdlib.h> 

int* sortedSquares(int* nums, int numsSize, int* returnSize) {
    *returnSize = numsSize; 

    int* result = (int*)malloc(numsSize * sizeof(int));
    if (!result) return NULL; 

    int left = 0, right = numsSize - 1;
    int index = numsSize - 1;

    while (left <= right) {
        int leftSquare = nums[left] * nums[left];
        int rightSquare = nums[right] * nums[right];

        if (leftSquare > rightSquare) {
            result[index] = leftSquare;
            left++; 
        } else {
            result[index] = rightSquare;
            right--; 
        }
        index--; 
    }

    return result;
}